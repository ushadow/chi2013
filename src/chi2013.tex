\documentclass{sigchi}

% Remove or comment out these two lines for final version
\toappearbox{\Large Submitted to CHI'13. \\Do not cite, do not circulate.}
\pagenumbering{arabic}% Arabic page numbers for submission. 

% Use \toappear{...} to override the default ACM copyright statement (e.g. for preprints).

% Load basic packages
\usepackage{balance}  % to better equalize the last page
\usepackage{graphicx} % for EPS, load graphicx instead
\usepackage{times}    % comment if you want LaTeX's default font
\usepackage{url}      % llt: nicely formatted URLs
\usepackage{tabularx}
\usepackage{subfigure}

% llt: Define a global style for URLs, rather that the default one
\makeatletter
\def\url@leostyle{%
  \@ifundefined{selectfont}{\def\UrlFont{\sf}}{\def\UrlFont{\small\bf\ttfamily}}}
\makeatother
\urlstyle{leo}


% To make various LaTeX processors do the right thing with page size.
\def\pprw{8.5in}
\def\pprh{11in}
\special{papersize=\pprw,\pprh}
\setlength{\paperwidth}{\pprw}
\setlength{\paperheight}{\pprh}
\setlength{\pdfpagewidth}{\pprw}
\setlength{\pdfpageheight}{\pprh}

% Make sure hyperref comes last of your loaded packages, 
% to give it a fighting chance of not being over-written, 
% since its job is to redefine many LaTeX commands.
\usepackage[pdftex]{hyperref}
\hypersetup{
pdftitle={SIGCHI Conference Proceedings Format},
pdfauthor={LaTeX},
pdfkeywords={SIGCHI, proceedings, archival format},
bookmarksnumbered,
pdfstartview={FitH},
colorlinks,
citecolor=black,
filecolor=black,
linkcolor=black,
urlcolor=black,
breaklinks=true,
}

% create a shortcut to typeset table headings
\newcommand\tabhead[1]{\small\textbf{#1}}


% End of preamble. Here it comes the document.
\begin{document}

\title{Making Touchscreen Keyboards Adaptive to Letter Keys, Hand Postures,  and Individual Users - An Hierarchical Spatial Backoff Model Approach}

% Note that submissions are blind, so author information should be omitted
\numberofauthors{3}
\author{
  \alignauthor 1st Author Name\\
    \affaddr{Affiliation}\\
    \affaddr{Address}\\
    \email{e-mail address}\\
  \alignauthor 2nd Author Name\\
    \affaddr{Affiliation}\\
    \affaddr{Address}\\
    \email{e-mail address}\\
  \alignauthor 3rd Author Name\\
    \affaddr{Affiliation}\\
    \affaddr{Address}\\
    \email{e-mail address}\\
}

% Teaser figure can go here
%\teaser{
%  \centering
%  \includegraphics{Figure1}
%  \caption{Teaser Image}
%  \label{fig:teaser}
%}

\maketitle

\begin{abstract}
(SZ: will deal with this later) As touchscreen keyboards are software based, the underlying spatial model for key press
classification can dynamically adapt to a number of factors such as the input 
hand posture, the individual, and the target key's position. These adaptations can
potentially improve the overall text entry experience on mobile devices. To 
combine these factors together, we introduce a hierarchical adaptive spatial 
model with back-offs. The hierarchical model consists sub-modules with different levels of
complexity. The highest order module is the most complex and specific one which adapts to 
all three factors whereas the lowest order one is the most general which is independent
of all the factors. As more data is needed to build a more complex module, we introduce
the back-off mechanism such that we can fall back to a less complex module if necessary.
We also evaluate the effectiveness of different adaptive models which gives 
guidance on the priority of these models to use. Finally, we
develop an online input posture classification method for touchscreen keyboard which can be
used with the adaptive spatial model to improve the key probability estimation accuracy.
 
\end{abstract}

\keywords{
  Touchscreen text input; posture adaptation; personalization; adaptive model.
}

\category{H.5.2.}{Information interfaces and presentation}{User interfaces}[input devices and strategies]

\section{Introduction}
The rapid growth of touchscreen based smartphones and tablets have made finger typing on touchscreens an everyday information input activity. Touchscreen keyboards, which can also be called Smart Touch Keyboards (STK) have advanced in their underlying technology in the past few years. Taking the publicly available open source Android keyboard as an example, a modern touch screen keyboard uses language modelling, spatial and edit distance based correction and other sophisticated techniques to predict, correct, and complete the user’s imprecise typing. Despite these engineering achievements, text input continues to be a mobile user experience bottleneck, particularly for business and productive use~\cite{Bao:2011}. Any further improvement to keyboarding experience, even by a small amount, is desired and important considering hundreds of millions people use their smartphone or tablet everyday.

One compelling direction of research for further improvement of touchscreen keyboard experience is adaptation and personalization of keyboard spatial models. A spatial model converts a touch point into probabilities of different letters, often in combination with language  modeling. Its adaptation and personalization
are most compelling on large touch surfaces where one can use ten fingers to do traditional desktop style touch (blind) typing. Findlater and Wobbrock~\cite{Findlater:2012} found measurable performance improvement when the keyboard touch typing model is personalized. This is quite plausible because users have different hand and finger sizes and shapes. Typing on a physical keyboard that is sized and shaped for the “average” user meant the not so average users have to stretch and move their fingers to reach all the keys. With soft keyboards, the underlying “keys” can shift and adapt to the individual user. Interestingly, they also found while adapting the underlying model was beneficial, changing the visual layout of the keyboard was not for ten-finger touch typing on large screens~\cite{Findlater:2012}.

In comparison to ten-finger blind typing on a large touch surface, the individual differences in one-finger or two-thumb typing on smartphones are more subtle but still compelling. People have different finger and thumb width therefore conceivably different touch precisions (as measured by variance of touch points) and bias (as measured by the mean offset)~\cite{Holz:2011}. Azednkot and Zhai~\cite{Azenkot:2012} did a systematic study of smartphone keyboard touch patterns under various typing conditions. We note the following observations based on their study:

\begin{enumerate}
\item People use different “hand postures” -- one finger, one thumb, and two thumbs -- to type on smartphones. Depending on the situation (e.g. sitting, standing or walking), the same individual may also change from one hand posture to another. For example, the same individual who normally types with two thumbs on a phone while sitting down may switch to one finger or one thumb typing while standing or walking. We cannot assume that the same individual will use the same hand posture all the time. Adaptation methods based on lab experiments with one consistent hand  posture, such as those in~\cite{Findlater:2012}, give important insights and guidance for designing practical systems. But they may also face challenges as practical solutions because user may change their hand posture in real world settings from their normal preference.

\item These hand postures change the touch typing patterns. For example for right handed users one finger and one thumb typing on the left side of a smartphone touchscreen keyboard tend to biased towards to the right direction, whereas two thumb typing on the left side of the keyboard tend to shift to the left direction.

\item Touch patterns can also be dependent on letter keys. For example for one finger typing users touch points tend to shift downward on the bottom letter row of a touchscreen keyboard, but not the top row. 

\item Users’ touch points tend to spread wider on a collective basis (polling or accommodating all users data together) than on an individual basis.
\end{enumerate}

Together these findings make a strong case and call for personalization of smartphone touch keyboard algorithms. However they also illustrate the challenge and complexity of personalization. Future advanced keyboards may need to adapt to individual differences as one factor,  but it is insufficient or even invalid if the keyboard algorithms do not also adapt to other adaptive factors, such as hand postures and keys (or regions). In other words, strong and effective adaptation may need to  take a combinatorial approach to be key, posture, and user specific. 

A combinatorial approach raises challenging implementation issues. First, there need to be a large number, such as 26 keys $\times$ 3 postures = 78, of submodels for each individual user. Collecting sufficient amount of data to build each submodel may take too long a time to be practically useful, especially for infrequent letters, such as Z and X. Second, if an STK does have a large number of (sub)models, model selection can be a significant challenge.  Since each submodel is specific to a combination of factors, a wrong selection may actually hurt the keyboard’s quality. Correct model selection requires an accurate identification of the current mode i.e. a combination of adaptive factors . While it is relatively easy to identify the individual (by for example device login) and letter key, it is not so easy to identify what hand posture the user is applying to each tap. 

To address these challenges, we propose and explore a hierarchical backoff approach to building adaptive STK spatial models. The models in the hierarchy range from generic (e.g. a base model that is user, key, and posture invariant) to specific (e.g. a spatial model for the letter W when tapped with the right index finger by the current user). Adaptive keyboards developed in such an approach, when put in use by an individual user, first start with the base model. A hierarchy of models, while other more specific models are dormant. Each touch input point is used for input decoding and contributes to building one or more submodels the touch point belongs. When a submodel “matures”, i.e. a sufficient amount of data is available to train it, it becomes active. A mature model will continue to renew itself with new user data to accommodate  slow and long term change of user behavior. When multiple submodels are active, the system first identifies the current input mode and then applies a more specific model if its corresponding model has matured and if such a mode is classified with high confidence. If either of the conditions is not met, the system backs-off to a more general model or the base model. This hierarchical back-off may offer the following advantages to the adaptation in a STK:
\begin{enumerate}
\item It (potentially) does combinatorial and fine grained adaptation, not only to the individual user as a lumped-together entity, but also in combination with hand posture and key location factors. It is therefore more practical and less brittle since it does not assume one user would always use the same hand posture in all situations.

\item It is conservative. Adaptation is only applied if and only if the more specialized mode is confidently detected and when its corresponding submodel is mature. It is biased towards the standard base model. In the worst case it is not different from or worse than the standard model. It therefore minimizes the risk of over adaptation and transitional instability when the user changes hand posture. 
 
\item The system does not require a separate training (data collection) phase for each individual. It is more practical to launch such an adaptive system.

\item The system continually updates and renewal itself, so it can accommodate long term user behavior change. 
\end{enumerate}
We call keyboard built in such an approach SBM (spatial backoff models) keyboard. The SBM approach also raises many questions and challenges which will be addressed in the rest of the paper. Here we give a brief outline to these problems and their solutions.

First, while the observations made in~\cite{Azenkot:2012} is quite unambiguous about key location, hand posture, and individual being reasonable adaptive factors, they need further investigation.  We report one analysis on the relative key detection power of various spatial models specific to the combinatorial factors of key, hand posture,  and individual in section ``Comparison of Spatial Model’’.

Second, in section ``Input Hand Posture Classification’’ we present a detailed SVM-based classifier of hand postures that returns mode identification of two-thumb or one-finger (including one-thumb) posture from users’ touch points while entering text.

Third, using the posture classification method and user adaptation, does higher order specific models really offer better error corrections than a lower order or base model without language model (as a baseline)? We address this question in the ``Evaluation of Standalone SBM” section. With our dataset it was found that posture specific spatial models could reduce character error rate by about 12.0\%; and user specific spatial models could reduce character error rate by about 14.7\%. The combination of the two could potentially give further improvement. 

Fourth, SBM is a rather complex approach involving multiple phases and components. A modern smartphone keyboard involves even more components such as a language model, a decoder, an event handling system and graphical user interfaces.  Can a SBM system really work when all of these are put together? Would any other components and functions of an entire system (e.g. a language model) washoff or even counteract with SBM adaptation? Is SBM keyboard technically feasible as a real-time interactive system? To address these questions, we have built a working SBM keyboard prototype by implementing the proposed hierarchical backoff models in a research keyboard called Delight. Delight is a working system that runs on Android OS and has a built-in language model and all essential functions of a modern commercial level smartphone keyboard. Its detail is beyond the scope of this paper.

\section{Research Methods}
As smartphone keyboard become more sophisticated, and given the relatively complex solutions proposed that involve multiple components, multiple phases, and learning,  we fear the traditional lab experiments based HCI evaluation method may not be efficient or sensitive enough for researchers to make rapid progress. In this paper we use a combination of HCI and ML (machine learning) evaluation methods, along with algorithm and system development. 

We first select a smartphone typing dataset as the empirical basis of training and cross-validation. The experiment that generated the dataset had been peer reviewed and published. Briefly, the experiment involved 32 participants who were given random phrases to type on a “data collector” keyboard run on a Android touchscreen phone.  The participants were encouraged to type as naturally as possible and not to correct any errors. The goal was to collect user’s touch patterns by their natural instinct with as little concern to technology constraint as possible. The experiment was between-subject in which each participant used one hand posture to type. For consistency, we removed the data from 2 left-handed users in our analysis, and are left with data from 9 users using one-index-finger input, 11 users using one-thumb input and
10 users using two-thumb input.  Since we found much less difference between the index finger condition and the single thumb condition and due to mode classification reliability concerns, we combine the index-finger input and one-thumb input together as one-finger condition. We also filtered out touch points that are 1.5 times the height of the key away from the center of the target key. After this, there are 84292 total touch points. For all evaluations, the ratio of the number of users using one-finger input to that using two-thumb input is kept the same for the training and testing data sets. 

A basic dependent variable (measure) of the dataset and any models built from it is “character error rate”. This is measured by the difference between the character in the target phrase and character determined from the touch point via a spatial model. Note although this rate can be viewed as a percentage of the total number of characters in the target phrase, it is to be interpreted with precaution. First, 0\% error rate may never be achievable given how the dataset was achieved. Second the absolute error rate maybe dataset dependent and is not necessarily what a user would experience in practice, but the comparative error rates across conditions are informative of the qualities of different models.

\section{Related Work}

There is a body of active research on using spatial model, language model, or a combination
of the two to improve text entry accuracy on a STK. For examples, 
Al Faraj et al. \cite{AlFaraj:2009} and Magnien et al. \cite{Magnien:2004} both use
visual highlight of the next possible keys to aid users' typing. Their predictions of the next keys are based on a language model. As our focus is on the 
spatial model, we will also mainly look at the related work in this aspect.    

Kristensson et al. \cite{Kristensson:2005} propose a geometric pattern matching technique to improve 
stylus input accuracy. They match the geometric pattern of the touch points on a stylus keyboard against patterns formed by 
the letter key center positions of legitimate words in a lexicon. Similar to this approach,
they also develop a gesture-based stylus input method where users only need to stroke between the keys \cite{Kristensson:2004}.
Their approaches essentially use a combination of spatial and language models. However, 
their spatial model is not adaptive. While our focus is on tapping input, the same adaptive spatial model approach
can be potentially applied to the gesture-based input.

In terms of spatial model that is adaptive to the keys (i.e. each key has its own model instead of
sharing the same one), Goodman et al. \cite{Goodman:2002} use bivariate Gaussian distribution with means, and
covariance matrices computed separately for each key in their study on stylus input. Zhai et al. \cite{Zhai:2002} also show that
the hit points for each key on a Metropolis keyboard \cite{Zhai:2000} are normally distributed and 
the centers of the distributions shift in different directions depending on the positions of
the keys. In their relative keyboard input system, Rashid et al. \cite{Rashid:2008} also use a different bivariate
Gaussian for each key. The error rate of their system is high because the lack of 
a priori determined keyboard position.

Building on \cite{Goodman:2002}, Gunawardana et al. \cite{Gunawardana:2010} use restricted bivariate Gaussian
models in their anchored key-target resizing method. Key-target resizing means dynamically
adjusting the underlying target areas of the keys based on their probabilities. The probabilities can 
be a combination of spatial model and language model probabilities.
They argue that overly aggressive
key-target resizing can sometimes prevent users from their desired text, and hence violate
users' expectation about keyboard functionality. They ensure that touch points within
the anchor area of a key is always detected as that key irrespective to the language model.

There is also a number of research related to personal adaptation besides the one~\cite{Findlater:2012} mentioned in Introduction. 
Rudchenko et al. \cite{Rudchenko:2011}
developed a text entry game that provides 
targeting words for users to type to improve their typing experience. As a side effect,
the game also generates labeled touch point data which can be used as
training data to build the spatial models. They explore the effect of personal adaptation
by using the touch points from the first 10 rounds of each 
participant's game play to build the personalized model for each key, and simulating the key detection
process for the second 10 rounds. Their result shows that with key-target resizing based on
spatial model only and using the training data from all the users combined
gives an error reduction of 18.9\% over no key-target resizing. When using personalized
key-target resizing, there is a further 2.84\% error reduction.
Their results show the benefit of individual adaptation in an ideal condition where the 
intended key is known. In the real world application, the keys users intend to hit are unknown and can only be inferred based on the current spatial and language models. In our prototype implementation, we build the user adaptive spatial model for each key dynamically as the user types. 

The key and individual adaptive methods mentioned earlier all assume that users' input posture
remain the same. We observe that the same individual may change hand posture even on the same device. Building on the observations made by Azenkot and Zhai [1], we investigate how posture adaptation can be implemented and how it can actually affect key probability estimation accuracy.

The idea of backoff to a lower order model when a higher order more specific model is not available is commonly used in language modelling for speech recognition~\cite{Zitouni:2007}. For example, when unseen \textit{n}-gram events are encountered, the backoff class based \textit{n}-gram language model is used.

Finally, various researchers have explored other dimensions to improve the overall
text input experience on touchscreen keyboard. One dimension is using hardware
augmentations to provide vibro-tactile feedback \cite{Brewster:2007, Hoggan:2008}. 
Another dimension is using alternative keyboard layouts that are optimized for typing speed (wpm)
based on Fitts' law and character level digraph frequencies \cite{Zhai:2000, MacKenzie:1999}.
These dimensions are orthogonal to the language and the spatial models, and can be potentially 
combined together to further increase the input accuracy and speed.

\section{Hierarchical Spatial Backoff Models (SBM)}
The hierarchical adaptive SBM consists of a number of sub-models in different “orders” (Figure. \ref{fig:hierarchy}). Each sub-model is represented by a bivariate Gaussian distribution $N(\underline\mu, \Sigma)$
where $\underline\mu \in \mathbb{R}^2$ is the mean $(x, y)$ offsets from the center of
each key's bounding box, and $\Sigma$ is a $2\times 2$ covariance matrix  
\cite{Azenkot:2012, Goodman:2002, Rashid:2008}.
The zeroth order is the base model which is key, individual, and posture
independent. This is the most general model combining all data together. The
higher order sub-models adapt to a combination of 
key positions, hand postures (e.g. one-finger or two-thumb), and individual users. 

\begin{figure}[tb]
  \centering
  \includegraphics[width=0.9\columnwidth]{figures/hierarchy.pdf}
  \caption{Hierarchical spatial backoff model}
  \label{fig:hierarchy}
\end{figure}

Each combination of the factors needs sufficient number of samples to build a reliable model. Hence, each sub-model would only become active when its reliability passes a set 
threshold. Otherwise a lower order model (back-off) will be used instead.

Figure~\ref{fig:hierarchy} shows a complete hierarchy of the sub-models with all
possible combinations of the three adaptive factors. However, depending on the
relative effectiveness of the sub-models, it is not necessary to include all of
them in the implementation. In this paper, we focus on analyzing the key
adaptive model, posture and key adaptive model and user and key adaptive model.
The order of the
back-off process, and the priority of the models at the same level to use can
also be design choices, but the analysis in the next section gives
guidance and suggestion on how to determine the order.

\section{Comparison of Spatial Models}
We compare key estimation error rate with different models to analyze their
relative effectiveness (Table \ref{tab:comparison}). This can inform us the order of the
back-off models to use when there is not enough data for higher order models.
10-fold cross validation is used, and the training and testing data sets have
different users.

\begin{table} [tb]
  \centering
  \begin{tabular}{|l|c|}
    \hline
    \tabhead{Spatial model} &
    \multicolumn{1}{|p{0.2\columnwidth}|}{\centering\tabhead{Key detection
    error rate}} \\
    \hline
    Distance from the center of the keys & 7.976\% \\
    \hline
    \multicolumn{1}{|p{0.7\columnwidth}|}{Base model (same Gaussian model for
    all the keys with a full covariance matrix)} & 7.853\% \\
    \hline
    Key adaptive model  & 8.023\% \\
    \hline
    Posture and key adaptive model & 7.058\% \\
    \hline
    Individual and key adaptive model  & 6.845\% \\
    \hline
  \end{tabular}
  \caption{Comparison of key detection accuracy (no language model) with
  different spatial models using 10-fold cross validation.}
  \label{tab:comparison}
\end{table}

Given a pair of touch point coordinates $\underline c \in \mathbb{R}^2$, the most likely intended key is given by 
\begin{align}
\hat k &= \arg\max_k p(k | \underline c) \\
          &= \arg\max_k \frac{p(\underline c, k)}{\sum_k p(\underline c, k)} \\
          &= \arg\max_k p(\underline c, k) \\
          &= \arg\max_k p(k)p(\underline c | k)
\end{align}
The $p(k)$ term is related to the language model, hence in our analysis of the spatial models, we assume $p(k)$ is the same for all $k$. As a result
\begin{align}
\hat k &= \arg\max_k p(\underline c | k)  \\
          &= \arg\max_k N_k(\underline c - \underline c_k; \underline\mu, \Sigma)
\end{align}
where $\underline c_k$ is the center of the visual bounding box of key $k$ and $N^k$ represents the sub-model selected for the key estimation.

The simplest model is a Gaussian distribution with 0 mean $x$ and $y$
 offsets and the same spherical covariance matrix for all the keys. Key
detection based on this model is essentially choosing the key that has the shortest Euclidean distance from the tapping coordinates. 
Our base model has a full covariance matrix $\Sigma$ trained from the
training data, but the same base model $N(\underline 0, \Sigma)$ is used for all keys.

\subsection{Key Adaptation}
A basic key adaptive model is a bivariate Gaussian model
$N(\underline\mu_k, \Sigma_k)$ for each key $k$ built  using data from all users in the training data set.

The result in Table~\ref{tab:comparison} shows no improvement of key adaptive model over the base model. This is because different hand postures tend to shift key specific spatial model in different ways, sometimes even in opposite directions. For example in Figure \ref{fig:key-adaptive}, we observe that the effective area of W key goes slightly beyond the visual key boundary between E and W. However, for one-finger input, there tend to right horizontal offsets for W key, while for two-thumb input, there tend to be left horizontal offsets. When mixing these opposite effects together in key adaptation, no meaningful results could be expected.

\begin{figure}[tb]
  \centering
  \subfigure[Key adaptive model]{
    \includegraphics[width=0.47\columnwidth]{figures/key-model.pdf}
    \label{fig:key-adaptive}
  } ~
  \subfigure[Posture and key adaptive model for one-finger input]{
    \includegraphics[width=0.47\columnwidth]{figures/posture-t.pdf}
    \label{fig:one-finger}
  }
  \subfigure[Posture and key adaptive model for two-thumb input]{
    \includegraphics[width=0.47\columnwidth]{figures/posture-tt.pdf}
    \label{fig:two-thumb}
  }
  \caption{Comparison of effective key areas with different spatial models.  Each colored area presents the region such that if the user taps in that region, the spatial model will classify that key with the corresponding key label.}
  \label{fig:key-boundary}
\end{figure}

\subsection{Posture Adaptation}
Key adaptation becomes more effective when combined with posture adaptation as
shown in Table~\ref{tab:comparison}. There is 12.0\% reduction in error rate 
compared to key adaptation only. The two-sample one-sided paired t-test shows
that the improvement in accuracy is significant when we use posture and key 
adaptation versus key adaptation only (t(29) = -2.4421, p = 0.01).

There can be different levels of complexity for posture adaptation. For the most complex one, we can have
two models for each key for each input postures, i.e., $N(\underline \mu_{y,k}, \Sigma_{y,k})$ for $y \in
\{\text{one-finger, two-thumb}\}$; or we can do posture adaptation only for a certain
number of keys. The best result is obtained when we only do posture adaptation for the keys on 
the left side, and for the keys on the right side, their Gaussian models are
independent of the posture, i.e., $N(\underline\mu_k, \Sigma_k)$.
The error rate for posture and key adaption shown in the table is based on 
posture adaptation for the keys on the left side. 

The choice of this set of keys is not arbitrary. As observed by Azenkot et al. \cite{Azenkot:2012}, the difference in horizontal
offsets of the touch points from different postures are most prominent for the keys on the
left set (Note that for left-handed users, the reverse is probably true). 
In addition, the analysis of variance based on the tapping coordinates from the
data set shows that, for different postures, there are significant differences in the means of
the $x$ coordinate for the keys on the left side of the keyboard ($p < 0.05$). 

Figure~\ref{fig:one-finger} and \ref{fig:two-thumb} show the comparison of effective areas of the keys
with spatial models adapted to one-finger input and two-thumb input respectively. Note how the key areas for the left-side keys shift to the left
for two-thumb input, and shift to the right for one-finger input. The difference in 
the effective key areas is the same concept as key-target resizing mentioned in \cite{Gunawardana:2010, Rudchenko:2011}.

The error rate in Table~\ref{tab:comparison} is based on perfect knowledge of
the posture which represents a lower bound for posture adaptation for this data
set. In the real world implementation, the online posture classification may
introduce errors. To mitigate the problem, the posture adaptive model can be turned on
when we have high enough confidence about the posture classification. The details are explained in a later section.

\subsection{Individual Adaptation}
The individual and key adaptive model gives a 14.7\% error reduction over key adaptive model. The result in the last row of Table~\ref{tab:comparison} is based on the 
following method. For each fold of the cross-validation, data from the training set are used to 
train the combined back-off key models. For each user in the test set,
50\% of the data for each key is used to train the individual and key adaptive
model, i.e., $N(\underline \mu_{u, k}, \Sigma_{u, k})$ where $u$ is from the test user set.
The accuracy of these data points are tested on the combined key models.
The remaining 50\% of the data for each user are tested on the user adaptive 
models. 

Figure~\ref{fig:user-adapt} shows how key detection error rate for key ``E'' 
changes as the number of points used to build
the personalized model for key ``E'' increases. The error rates are obtained using cross-validation
as well and are based on the touch points that are not used in building the
model. We choose ``E'' as an
example because it has the most number of data points (around 90) for each
user in our data set besides the ``Space'' key. For other keys, there are
relatively small number of data points, and hence it is hard to do the
analysis on them. However, we believe the result would be applicable to other
keys. Also due to the limited number
of data points, we only show the trend until the number of touch points used to build the individual
model is 70. Nevertheless, the figure still shows a general trend, and suggests 
that the minimum number of data points for building a individual key adaptive model
should be at least 60, but a number in the order of a hundred is probably better. When
there are not enough data points, a back-off model like the posture and key adaptive model can be used.

\begin{figure}[tb]
  \centering
  \includegraphics[width=0.9\columnwidth]{figures/individual-adapt.pdf}
  \caption{Graph showing how key detection error rate for key ``E'' changes as the number of
  points used to build the individual adaptive model for key ``E'' increases.}
  \label{fig:user-adapt}
\end{figure}

\section{Input Hand Posture Classification}\label{sec:posture-classification}
The hierarchical adaptive SBM needs real time classification of the user’s hand postures. A variety of sensors, signals and algorithms can be used in the future to achieve such a function. We developed an online binary hand-posture classifier 
that constantly returns an estimate of the user's current posture (two-thumb or one-finger input) from the user’s text input touch points without additional sensors. 

Let $\mathcal{Y} = \{\text{one-finger}, \text{two-thumb}\}$ be the set of posture
class labels. We describe in detail the classification function that maps input from the
touch points to $\mathcal{Y}$.

Our method of hand-posture classification is based on Fitts’ law which states that the time (T) required to move to a target is a function of the distance (D) to the target and the size (W) of the target (Equation 1).
\begin{align}
T = a + b\log_2(1 + \frac{D}{W})
\end{align}                                                  
We expect one-finger input posture follows this law,  but two-thumb input may not. For example, a user may take a longer time to type the letters AL using one finger because the finger has to travel a longer distance from key A to key L on a Qwerty keyboard. With two thumbs, typing AL can be faster because the touch action switches from left thumb to type A to the right thumb to type L, and no long distance travel is required.

\begin{figure}[tb]
  \centering
  \includegraphics[width=0.9\columnwidth]{figures/time-distance.png}
  \caption{Touch points data from input on a Nexus S phone.}
  \label{fig:time-distance}
\end{figure}

Figure. \ref{fig:time-distance} shows the relationship between the time elapsed 
and the log square distance travelled between consecutive key taps. We can
see that for the one-finger input (blue and red points), the time taken
increases with distance whereas for the two-thumb input, there is no obvious
trend. The difference is more significant when the log square distance (natural
log) is greater than 10 px.

Based on this finding, we include the time elapsed and the log square distance
between two consecutive key presses as the features for the posture classifier. 
To account for individual typing speed differences, we also use normalized time 
elapsed between consecutive key presses as the third feature. It is calculated 
by dividing the time elapsed by the average time elapsed for the last 10 key
presses.

Using 20 users’ data for training and 10 users’ data for testing, we train a SVM classifier offline with these 3 features for touch points that satisfy condition $C$: it is 
on the different side of the keyboard from its previous touch point and the log square distance from the previous touch point is at least 10px. This classifier gives a probability score $p_y^{\text{single}}$ for these touch points. Note that $\displaystyle\sum_{y \in \mathcal{Y}}p_y^{\text{single}} = 1$. The posture classification accuracy for these touch points is 83.6\%.
 
In order to classify every key tap and assuming the user does not change posture 
rapidly, we look at a sliding time window of 10 touch points (about 2 words). For 
each time window, we use another SVM classifier with the following features:
\begin{enumerate}
\item Correlation between time elapsed and log distance (this feature has the
advantage of being speed independent) (see Figure. \ref{fig:boxplot}).
\item Sum of $p_\text{one-finger}^{\text{single}}$ for touch points satisfying condition $C$.
\item Sum $p_\text{two-thumb}^{\text{single}}$ for touch points satisfying condition $C$.
\item Number of touch points classified as one-finger input.
\item Number of touch points classified as two-thumb input.
\end{enumerate}
Features 2-4 are also normalized by the window size. The history of the touch points are cleared for every new typing session.
The choice of the size of the sliding window represents a trade-off between the 
accuracy of the classification and how responsive the system is when the user
changes posture. We found that the assumption that the user does not change posture
often within 2 words is reasonable, but more work can be done to investigate this
aspect, and even to test with a window size of 1 (i.e. not 
looking at the history).

The sliding time window classifier gives a final probability score $p_y$ for posture
$y$ for each touch point. Again $\displaystyle\sum_{y\in \mathcal{Y}}p_y = 1$. To evaluate the classification accuracy, we set the the
classified posture to be $y$ if $p_y > 0.5$. With this, the overall classification 
accuracy for each touch point with a sliding time window
is 86.4\% (23128 out of 26769 touch points).

Because of the sliding window approach, the posture for the first few touch points  
for each new session is unknown. In this case, the system backed off to a lower order spatial 
model (key adaptive or base model). Furthermore  it turns on the posture 
adaptive spatial model only when the probability score for one posture is much 
higher than the other.

\begin{figure}[tb]
  \centering
  \includegraphics[width=0.8\columnwidth]{figures/boxplot.pdf}
  \caption{Correlation between time elapsed and log square distance between
  consecutive key presses for every 10 keys. There is a stronger correlation for
  one- finger input than that for two-thumb input.}
  \label{fig:boxplot}
\end{figure}

\section{Implementation and Evaluation}
The key probability estimation process with the proposed SBM fits nicely with the
Chain of Responsibility design pattern.
Figure~\ref{fig:chain-of-responsibility} shows a simplified version of an object
diagram showing the interaction between various models. Each higher order model can
have a reference or references to lower order models. When given a pair of touch
point coordinates, the system queries the highest order model for a Gaussian
sub-model for a particular individual/posture/key combination. If it is not present, 
the higher model calls the lower model, and the
query propagates until a Gaussian sub-model is found. 

\begin{figure}[tb]
  \centering
  \includegraphics[width=1\columnwidth]{figures/chain-of-responsibility.pdf}
  \caption{An object diagram showing the interaction between higher and lower
  order spatial models.}
  \label{fig:chain-of-responsibility}
\end{figure}

Based on this design, we implemented a prototype of SBM with the online posture classification in C++. The prototype SBM has flags to turn on/off curtain adaptive models so that we can easily compare the effectiveness of submodels with different combinations of adaptive factors. For all the evaluations, we use 20 users' data for training both the posture classifier and the spatial models, and test on the other 10 users' data. 

\subsection{Evaluation of Standalone SBM}
First, like \cite{Findlater:2012, Rudchenko:2011}, we evaluate the effectiveness of the standalone SBM  prototype on key estimation without a language model. 
Table~\ref{tab:off-device} shows the comparison of
key estimation error rates using SBM with different submodels turned on.

\begin{table}[tb]
  \centering
  \begin{tabularx}{\columnwidth}{|X|c|}
  \hline
  \tabhead{Highest order spatial model in SBM} & \tabhead{Error rate} \\
  \hline
  \multicolumn{1}{|p{0.7\columnwidth}|}{Base model} & 8.641\% \\
  \hline
  Key adaptive model & 8.708\% \\
  \hline
  Posture and key adaptive model & 8.394\% \\
  \hline
  Individual and key adaptive model  & 7.621\%
  \\
  \hline
  Posture, individual and key adaptive model &  7.498\%
  \\
  \hline
  \end{tabularx}
  \caption{Comparison of key estimation error rates using standalone SBM model with different submodels. Results are based on 10 test users.}
  \label{tab:off-device}
\end{table}

\subsubsection{Posture Adaptation}\label{sec:off-device-posture}
The posture and key adaptive model uses the posture classification
method described in the previous section. As a result, the
key detection error rate for using this model is compounded with the posture
classification error rate as well. 

An error in posture classification will lead to a choice of wrong submodel,
and hence adversely affect the key detection accuracy. The confidence of the classification is reflected by the pair of probability 
scores $(p_{\text{one-finger}}, p_{\text{two-thumb}})$ returned by the classifier. 
We can set a threshold $T_{\text{posture}}$ such that the input posture is classified
as $y$ only if $P_y \ge T_{\text{posture}}$ . Otherwise the posture is treated as
unknown and we backoff to a lower order spatial model.

There is also a trade-off in setting the threshold $T_{\text{posture}}$. The higher
 $T_{\text{posture}}$ is, the fewer the number of errors there are in posture classification, but it also means the more touch points will be classified as from unknown posture and no posture adaptation is used for these touch points. Figure~\ref{fig:posture-confidence} 
 shows that there is an optimal level of the threshold beyond which the error rate
 increases because we no longer take the advantage of posture adaptation. The error rate in Table~\ref{tab:off-device} for SBM with posture and key adaptive model as the highest order model is obtained by setting $T_{\text{posture}} = 0.94$.

\begin{figure}[tb]
 \includegraphics[width=0.9\columnwidth]{figures/error-confidence-cropped.pdf}
  \caption{Graph showing how key detection error rate changes as the confidence
  threshold for posture classification increases.}
  \label{fig:posture-confidence}
\end{figure}

To further investigate the effect of posture adaptation, we look at the detection
errors represented in confusion matrices (see Figure~\ref{fig:confusion-matrices}). Figure~\ref{fig:error-key} and \ref{fig:error-posture}
show the errors when using key adaptive model, and posture and key adaptive model respectively. Figure~\ref{fig:error-key-posture}
and \ref{fig:error-posture-key} shows errors in one model but not the other.
We can see that when using posture and key adaptive model we also incur errors
that are not present when using key adaptive model alone. However the number of these
errors are much smaller compared to the errors corrected.

\begin{figure*}[tb]
  \centering
  \subfigure[Errors when using key adaptive model]{
    \includegraphics[width=0.49\columnwidth]{figures/sim-result-1.pdf}
    \label{fig:error-key}
  } 
  \subfigure[Errors when using posture and key adaptive model]{
    \includegraphics[width=0.49\columnwidth]{figures/sim-result-2.pdf}
    \label{fig:error-posture}
  }
  \subfigure[Errors when using key adaptive model but not when using posture and key
  adaptive model]{
    \includegraphics[width=0.49\columnwidth]{figures/sim-result-1-2.pdf}
    \label{fig:error-key-posture}
  }
  \subfigure[Errors when using posture and key adaptive model but not when using key
  adaptive model]{
    \includegraphics[width=0.49\columnwidth]{figures/sim-result-2-1.pdf}
    \label{fig:error-posture-key}
  }
  \subfigure{
    \includegraphics[width=0.3\columnwidth]{figures/sim-result-colorkey.pdf}
  }
  \caption{Confusion matrices for key detection evaluation with different
  spatial models as the highest order model. The row labels are the
  target keys, and the column labels are the predicted keys.  The color of the cells
represents the number of errors for a particular pair of confusion. The more red the color,
the greater the number of errors.}
  \label{fig:confusion-matrices}
\end{figure*}

Figure~\ref{fig:error-key-posture} also shows that the most number of
corrections by using posture and key adaptive model is for the E and W pair. Figure~\ref{fig:e-w-ellipses}
shows a closer look at the Gaussian distributions for the two keys for the different
adaptive models. We can see the Gaussian distributions for key adaptive model (black ellipses) shift slightly to the right. This causes the touch points on the boundary between W and 
E to be mis-classified as W. However, the ellipses based on the posture and key
adaptive model for the two-thumb input shift to the left slightly, and this changes
the classification of those boundary points to E correctly.

\begin{figure}[tb]
  \centering
  \includegraphics[width=1\columnwidth]{figures/key-posture-ellipse.png}
  \caption{Each ellipse represents the 0.95 confidence ellipse of the Gaussian model built based on a set of touch points. Each black ellipse is based on the all touch points intended for either W or E. Each blue ellipse is based on touch points from two-thumb input only. The red points are the touch points intended for E but are mis-classified as W when using the key adaptive model. 
}
  \label{fig:e-w-ellipses}
\end{figure}

\subsubsection{Individual Adaptation}
For individual adaptive model, we set the minimum number of points needed to build the
Gaussian model for a particular key for a particular individual to be 50. Ideally we would want like to set this number higher for better model reliability as shown in Figure~\ref{fig:user-adapt}. However the current number is 
limited by the amount of data we have because there are not many keys that has 
the number of touch points be greater than 50 in our dataset. 

For every touch point, we compute the probability for each key given the underlying spatial model. Then we use the $(x, y)$ coordinates of the touch point to update the Gaussian model
for the most probable key. Updating the Gaussian model involves computing the running
average of the $x, y$ offsets from the center of the key and the covariance matrices. The counter for the number of points used for a particular key Gaussian is maintained so that we
know when a particular Gaussian model becomes valid, i.e. has enough data points.

When there is not enough data points, the system backs-off to a lower order model.
Here we can have a choice of whether backing-off to the posture and key adaptive model or 
to the key adaptive model. Backing-off to the posture and key adaptive model means
classify the user's current posture and use the corresponding posture and key model for key detection instead
of just using the key model which is posture independent. The last two rows in 
Table~\ref{tab:off-device} shows that there is also a slight more error reduction  in backing-off to
the posture and key adaptive model.

Note that because the data set we have is from a between-user study, we cannot look
at the effect of posture adaptation for each individual, i.e., each individual has two Gaussian models
for each posture and key combination.

\subsection{Keyboard Integration: Delight-SBM}
To demonstrate the feasibility of the hierarchical SBM in a real system, we integrate the prototype with the Delight research keyboard, and call it Delight-SBM. 
Delight-SBM runs on Android devices in real-time. Its input decoding process combines SBM with a language model. During the decoding process, given a sequence
of touch points $\underline c_1\ldots\underline c_n$, Delight-SBM computes 
the probability of each touch point to
each key in a candidate word using the SBM.
The probabilities are then combined with the word probability based on the 
language model to give the final probability of the intended word.

To observe the interaction between SBM and a language model, we put Delight-SBM to an on-device test. As a preliminary evaluation, we compare SBM with the posture and key adaptation as the highest order model and the one with key adaptation as the highest level to isolate the effect of posture adaptation. We fed Delight-SBM with the touch data in real-time (at the same time intervals the touch data were recorded) through Android’s Monkey event emulation tool. To establish a baseline, we choose the most basic language model first such that all the words in the dictionary have the same probability. It does not correct substitution, insertion or deletion errors either. 

The metric we use for evaluation is the mean word error rate between target phrases and detected phrases after auto correction. The word accuracy score is based on minimum
word distance (MWD) error rate which is the smallest number of word deletions, insertions, or replacements needed to transform
from the target phrase into the detected phrase divided by the maximum of the 
lengths of the two phrases. Again, the absolute MWD error rate is not necessarily what a user would experience in practice, but the comparative MWD error rates across conditions are informative of the keyboard’s quality.

With key adaptive model only, the error rate is 19.922\%; and with posture and key
adaptive model, the error rate is 19.471\%, a reduction of 2.3\%. Table~\ref{tab:on-device} shows some examples
in the test users where the detected phrases are correct when using posture and key adaptive spatial model, but
are wrong when using key adaptive only spatial model. We can see that in those examples,
the posture and key adaptive model can correctly detect the phrases because it
correctly distinguish the neighboring keys between A and S, S and D,
D and F, F and G, W and E. There are also a smaller number of cases where the detected phrases using key 
adaptive model is correct, but the ones using posture and key adaptive model are
wrong. These usually occur when the posture classification is wrong. 

\begin{table*}[tb]
  \centering
  \begin{tabularx}{0.925\textwidth}{|l|l|l|l|}
  \hline
  \tabhead{Input posture} & \tabhead{Target phrase} & \tabhead{Detected phrase with key adaptive model} 
  & \multicolumn{1}{|p{0.526\columnwidth}|}{\tabhead{Detected phrase with posture and key adaptive model}}\\
  \hline
  two-thumb & the dreamers of dreams & the \textcolor{red}{dream era} of dreams & the dreamers of dreams  \\
  \hline
  two-thumb & handicapped persons & \textcolor{red}{handicap pes} persons & handicapped persons \\
  \hline
  two-thumb & she wears too much makeup & \textcolor{red}{a he} wears too much makeup & she wears too much makeup \\
  \hline
  one-finger & my bare face in the wind & my bare face in the \textcolor{red}{wins} & my bare face in the wind \\ 
  \hline
  two-thumb & a lie makes the nose grow & a lie \textcolor{red}{ma kea} the nose grow & a lie makes the nose grow \\
  \hline 
  two-thumb & the bathroom is clean & the bathroom is \textcolor{red}{cl wan} & the bathroom is clean \\
  \hline 
  two-thumb & travel at light speed & travel at light \textcolor{red}{a peed} & travel at light speed \\ 
  \hline
  two-thumb & traveling requires fuel & \textcolor{red}{travel inf require a} fuel & traveling requires fuel \\
  \hline 
  two-thumb & most golfers love the game & most \textcolor{red}{gold ers} love the game & most golfers love the game \\ 
  \hline
  two-thumb & win first prize & win \textcolor{red}{dir st} prize & win first prize \\ 
  \hline
  two-thumb & if at first you fail & if at \textcolor{red}{dir st} you fail & if at first you fail \\ 
  \hline
  \end{tabularx}
  \caption{Examples of on-device simulation where the detected phrase is correct
  with posture and key adaptive spatial model and incorrect with key adaptive spatial
  model.}
  \label{tab:on-device}
\end{table*}

The result shows that the posture adaptive spatial model can potentially be combined 
with language model to give better auto correction result even though posture
classification may not be perfect. 

\section{Discussion}
The results based on our dataset suggest that we
can give higher priority to individual adaptation when we do not have enough data for
the highest order model (i.e., the posture, individual and key adaptive model). 
If there are still not enough data for the individual and key adaptive model, we 
can backoff to posture and key adaptive model. Figure~\ref{fig:partial-hierarchy} 
shows a possible partial hierarchical model and backoff paths taking into consideration
of the effectiveness of the adaptive models. The result in the
last row of Table~\ref{tab:off-device} is obtained using this spatial model.

\begin{figure}
  \centering
  \includegraphics[width=0.9\columnwidth]{figures/partial-hierarchy.pdf}
  \caption{Partial hierarchical model implemented in our prototype. The numbers indicate the order of the 
submodels to use during backoff.}
  \label{fig:partial-hierarchy}
\end{figure}
The on-device evaluation with posture adaptation and a simple language model shows promising result, but there are
more work to be done to explore the interaction between posture and individual adaptation and
a more sophisticated language model. It would also be interesting to study how
to use posture detection to guide transposition error correction, because transposition error
is more likely to occur when two hands are used to type.

An important limitation of our exploration thus far is the limited dataset available. Much greater amount of data than what is typically collectable from lab experiments  is needed in the future to continue this line of work. Methods such as real use logging with strict privacy preservation and game playing~\cite{Rudchenko:2011} can be possibly employed to gather a large body of data. Because of the dataset limit, what we have addressed is fundamentally an \textit{approach} to STK spatial model adaptation. The specific (sub)models, the backoff procedure and sequence, and certainly the parameters learned from the data, may be changed and optimized in the future. 

\section{Conclusion}
We have introduced and evaluated a novel hierarchical adaptive spatial model for
touchscreen keyboard. Through comparative submodel analysis,  evaluation of a prototype implementation, we have shown that both posture and user adaptation for the spatial model can improve key probability estimation and key detection accuracy. When they are combined, they can
give the most improvement. The adaptations can potentially
improved the auto-correction accuracy when combined with language models. For real world
implementation, the
hierarchical structure gives a systematic way of backing-off  when data is limited
or we want to be conservative, e.g., when the posture classification confidence is not 
high enough. 

We have also developed a new touchscreen input posture classification method
that achieves an accuracy of 86.4\% for classifying one-finger and two-thumb input. When
combined with the adaptive spatial model, the overall key detection accuracy is increased
in our simulation.

\section{Acknowledgments}
We want to thank our team members (names omitted for review) for their insightful
suggestions and help in  our data analysis and implementation of the prototype. 

\balance

% If you want to use smaller typesetting for the reference list,
% uncomment the following line:
\small
\bibliographystyle{acm-sigchi}
\bibliography{chi2013}
\end{document}


